//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */

// ReSharper disable InconsistentNaming

import { MnestixFetch } from '../infrastructure';
import { ApiResponseWrapper } from 'lib/util/apiResponseWrapper/apiResponseWrapper';

export class TemplateClient {
    private http: MnestixFetch;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: MnestixFetch) {
        this.http = http
            ? http
            : {
                  fetch: () => {
                      throw new Error('MnestixFetch instance required');
                  },
              };
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '';
    }

    static create(_baseUrl: string = '', http?: MnestixFetch): TemplateClient {
        return new TemplateClient(_baseUrl, http);
    }

    /**
     * ONLY FOR INTERNAL USAGE. BearerToken needed.
     Creates a new custom template in the custom templates AAS of the given submodel semantic id.
     * @param defaultSubmodel The default submodel as json string
     * @return The identifier of the new created submodel in the custom templates AAS.
     */
    createCustomSubmodel(defaultSubmodel: any, signal?: AbortSignal | undefined): Promise<string> {
        let url_ = this.baseUrl + '/api/Template/createCustomSubmodel';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(defaultSubmodel);

        let options_: RequestInit = {
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
            },
        };

        return this.http.fetch(url_, options_).then((_response) => {
            return this.processCreateCustomSubmodel(_response);
        });
    }

    protected processCreateCustomSubmodel(response: ApiResponseWrapper<unknown>): Promise<string> {
        if (response.isSuccess) {
            return Promise.resolve(response.result as string);
        } else {
            const status = response.httpStatus || 500;
            const message = response.message || 'An unexpected server error occurred.';
            let _headers: any = {};

            if (status === 400 && response.result) {
                const result400 = ProblemDetails.fromJS(response.result);
                return throwException('A server side error occurred.', status, message, _headers, result400);
            } else {
                return throwException(message, status, message, _headers);
            }
        }
    }

    /**
     * ONLY FOR INTERNAL USAGE. BearerToken needed.
     Updates a custom template in the custom templates AAS.
     * @param customSubmodel The submodel to update as json string
     * @param submodelId The id of the submodel
     */
    updateCustomSubmodel(customSubmodel: any, submodelId: string, signal?: AbortSignal | undefined): Promise<void> {
        let url_ = this.baseUrl + '/api/Template/updateCustomSubmodel/{submodelId}';
        if (submodelId === undefined || submodelId === null)
            throw new Error("The parameter 'submodelId' must be defined.");
        url_ = url_.replace('{submodelId}', encodeURIComponent('' + submodelId));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(customSubmodel);

        let options_: RequestInit = {
            body: content_,
            method: 'POST',
            signal,
            headers: {
                'Content-Type': 'application/json',
            },
        };

        return this.http.fetch(url_, options_).then((_response) => {
            return this.processUpdateCustomSubmodel(_response);
        });
    }

    protected processUpdateCustomSubmodel(response: ApiResponseWrapper<unknown>): Promise<void> {
        if (response.isSuccess) {
            return Promise.resolve();
        } else {
            const status = response.httpStatus || 500;
            const message = response.message || 'An unexpected server error occurred.';
            let _headers: any = {};

            if (status === 400 && response.result) {
                const result400 = ProblemDetails.fromJS(response.result);
                return throwException('A server side error occurred.', status, message, _headers, result400);
            } else {
                return throwException(message, status, message, _headers);
            }
        }
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any };

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property)) this[property] = _data[property];
            }
            this.type = _data['type'];
            this.title = _data['title'];
            this.status = _data['status'];
            this.detail = _data['detail'];
            this.instance = _data['instance'];
            if (_data['extensions']) {
                this.extensions = {} as any;
                for (let key in _data['extensions']) {
                    if (_data['extensions'].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data['extensions'][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any };

    [key: string]: any;
}

export class AasDataSupplyResult implements IAasDataSupplyResult {
    templateId?: string;
    success?: boolean;
    message?: string;
    generatedSubmodelId?: string;

    constructor(data?: IAasDataSupplyResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data['templateId'];
            this.success = _data['success'];
            this.message = _data['message'];
            this.generatedSubmodelId = _data['generatedSubmodelId'];
        }
    }
}

export interface IAasDataSupplyResult {
    templateId?: string;
    success?: boolean;
    message?: string;
    generatedSubmodelId?: string;
}

export interface IAddDataToAasRequest {
    language: string;
    data: any;
    customTemplateIds: string[];
}

export interface IAasIds {
    assetId?: string;
    assetIdShort?: string;
    aasId?: string;
    aasIdShort?: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any,
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new ApiException(message, status, response, headers, null);
}
